#!/usr/bin/perl -w
#
# Verifies the checksum of a file.
#
# A.Gaponenko, 2015, 2016
#

use strict;

use English '-no_match_vars';
use Getopt::Long;
use LWP::UserAgent;
use HTTP::Request::Common;
use JSON;
use File::Basename;
use File::stat;
use Cwd 'abs_path';
use Time::HiRes qw(gettimeofday tv_interval);
use Digest;
use Data::Dumper;

use lib dirname($0);
use Mu2eSWI;

use Class::Struct Mu2eEnstoreInfo => [label=>'$', location_cookie=>'$'];

my $add_location;
my $redo=0;
my $verbosity=3;
my $sw = Mu2eSWI->new;

my %opt = ( 'add-sam-location'=>\$add_location,
            'redo'=>\$redo,
            verbosity=>\$verbosity,
            help=>0,
            %{$sw->optDefaults},
    );

# stat counters for the processing
my $numTotalFiles = 0;
my $numNoSam = 0;
my $numSkipped = 0;
my $numGood = 0;
my $numNoTape = 0;
my $numBad = 0;
my $numAddedLocation = 0;

my $totalReadBytes = 0;
my $totalSHATime = 0;

my $totalMetadataQueryTime = 0.;
my $totalLocationQueryTime = 0.;
my $totalLocationUpdateTime = 0.;

#================================================================
sub getSamSha($$) {
    my ($sw,$pathname) = @_;
    my $fn = basename($pathname);

    # Get sha256 from file metadata
    my $req = HTTP::Request->new(GET => $sw->read_server.'/sam/mu2e/api/files/name/'.$fn.'/metadata?format=json');

    my $numtries = 0;
    my $delay = $sw->delay;
    while(1) {
        ++$numtries;

        my $t1 = [gettimeofday()];
        my $res = $sw->ua->request($req);
        $totalMetadataQueryTime += tv_interval($t1);
        my $now_string = localtime();

        if ($res->is_success) {
            my $jstext = $res->content;
            print "got json = $jstext\n" if $verbosity > 8;
            my $js = from_json($jstext);

            my $jssha = ${$js}{'dh.sha256'};
            die "Error: no dh.sha256 SAM record for file $pathname on $now_string\n" unless defined $jssha;
            return $jssha;
        }
        else {
            if(404 == $res->code) {
                # this file has not been registered in SAM
                return undef;
            }
            else {
                print STDERR "Error querying metadata for file $fn: ",$res->status_line," on $now_string\n" if $verbosity > 0;
                print STDERR "Dump of the server response:\n", Dumper($res), "\n" if $verbosity > 8;
                if($numtries >= $sw->maxtries) {
                    die "Error: $numtries tries failed. Stopping on $now_string due to: ",
                    $res->status_line, ".\n", $res->content,"\n";
                }
                else {
                    print STDERR "Will retry in $delay seconds\n" if $verbosity > 0;
                    sleep $delay;
                    $delay += int(rand($delay));
                }
            }
        }
    }
}

#================================================================
sub isNotVerified($$) {
    my ($sw, $pathname) = @_;
    my $fn = basename($pathname);

    my $t1 = [gettimeofday()];
    my $req = HTTP::Request->new(GET => $sw->read_server."/sam/mu2e/api/files/name/$fn/locations?format=json");

    my $numtries = 0;
    my $delay = $sw->delay;
    while(1) {
        ++$numtries;

        my $res = $sw->ua->request($req);
        $totalLocationQueryTime += tv_interval($t1);

        if ($res->is_success) {
            my $jstext = $res->content;
            my $js = from_json($jstext);
            print "Got locations for $fn: ",Dumper($js), "\n" if $verbosity > 8;

            die "Error: expect a JSON array when querying file locations.  Got instead: '$jstext' on ".localtime()."\n"
                unless ref $js eq 'ARRAY';

            foreach my $entry (@$js) {
                my $loc = ${$entry}{'location'};
                my $dn = dirname($pathname);
                return 0 if defined $loc and $loc =~ m|$dn|;
            }

            return 1;
        }
        else {
            print STDERR "Error querying locations for file $fn: ",$res->status_line," on ".localtime()."\n" if $verbosity > 0;

            print STDERR "Dump of the server response:\n", Dumper($res), "\n" if $verbosity > 8;

            if($numtries >= $sw->maxtries) {
                die "Error: $numtries tries failed. Stopping on ".localtime()." due to: ",
                $res->status_line, ".\n", $res->content,"\n";
            }
            else {
                print STDERR "Will retry in $delay seconds\n" if $verbosity > 0;
                sleep $delay;
                $delay += int(rand($delay));
            }
        }
    }
}

#================================================================
sub tapeBacked($) {
    return $_[0] =~ /$ENV{MU2E_DSROOT_TAPE}/;
}

#================================================================
sub default_add_location($) {
    # By default add location for tape-backed files
    return tapeBacked($_[0]);
}

#================================================================
sub queryBFID($) {
    my ($bfid) = @_;

    my $file_info = `enstore info --bfid $bfid`;
    die "Error from enstore info for BFID $bfid\n" unless defined $file_info;

    $file_info =~ m/'external_label'\s*:\s*'(.+)'/
        or die "Error parsing file info: can't extract external_label from:\n$file_info\n";
    my $label = $1;

    $file_info =~ m/'location_cookie'\s*:\s*'(.+)'/
        or die "Error parsing file info: can't extract location_cookie from:\n$file_info\n";
    my $cookie = $1;

    return ( Mu2eEnstoreInfo->new(label=>$label, location_cookie=> $cookie), $file_info );
}

sub filterLocationCookie($) {
    my ($fi) = @_;
    my $cookie = $fi->location_cookie;
    $cookie =~ s/_//g;
    $cookie =~ m/^\d+$/ or die "Unexpected format of location_cookie='",
    $fi->cookie,"' for a non-SFA file.";
    return Mu2eEnstoreInfo->new(label=>$fi->label, location_cookie=> 0 + $cookie);
}

my $enstore_checked = 0;
sub getEnstoreInfo($) {
    my ($pathname) = @_;

    if(not $enstore_checked) {
        my $out = `enstore -h`;
        die "Error running 'enstore' command\n" unless defined $out;
        $enstore_checked = 1;
    }

    my $file_bfid = `enstore pnfs --bfid $pathname 2>/dev/null`;
    if($? ne 0) {
        return undef; # the file is not on tape yet.
    }
    chomp $file_bfid;

    my ($fi, $file_info) = queryBFID($file_bfid);

    # Check for SFA.  Per cs-doc-4698v4 "Enstore Small File Aggregation User Guide"
    # external_label for a package member will contain ':'
    if($fi->label =~ /:/) {

        if($file_info =~ m/'package_id'\s*:\s*None/i) {
            return undef; # not packaged yet
        }

        $file_info =~ m/'package_id'\s*:\s*'(.+)'/
            or die "Error parsing file info: can't extract package_id from:\n$file_info\n";

        my $package_bfid = $1;

        my ($pkg, $pkg_info) = queryBFID($package_bfid);

        return filterLocationCookie($pkg);
    }

    return filterLocationCookie($fi);
}

#================================================================
sub hexdigest($) {
    my ($pathname) = @_;

    my $t1hash = [gettimeofday()];

    # compute sha256 for the file
    my $dig = Digest->new('SHA-256');
    open(my $fh, '<', $pathname) or die "Error opening $pathname for reading: $! on ".localtime()."\n";
    $dig->addfile($fh);
    close $fh;

    $totalSHATime += tv_interval($t1hash);

    my $st = stat($pathname) or die "Error stating $pathname: $! on ".localtime()."\n";
    $totalReadBytes += $st->size;

    return $dig->hexdigest;
}

#================================================================
sub makeSamLocation($$) {
    my ($pathname, $tapeinfo) = @_;
    my $dir = dirname($pathname);

    if(tapeBacked($pathname)) {
        return 'enstore:'.$dir.'('.$tapeinfo->location_cookie.'@'.$tapeinfo->label.')';
    }
    else {
        return "dcache:".$dir   if $dir =~ m|^/pnfs/mu2e/persistent|;
        return "dcache:".$dir   if $dir =~ m|^/pnfs/mu2e/scratch|;
        die "Error: makeSamLocation('$pathname'): unknown file location.\n";
    }
}

#================================================================
sub maybeAddLocationToSam($$$) {
    my ($sw, $pathname, $tapeinfo) = @_;
    my $fn = basename($pathname);

    my $location = makeSamLocation($pathname, $tapeinfo);

    # Note: the documentation at
    # https://cdcvs.fnal.gov/redmine/projects/sam-web/wiki/Interface_definitions
    # specifies HTTP PUT for adding a location. However it seems we should use POST instead.

    my $dryrun = not ($add_location // default_add_location($pathname));

    print +($dryrun ? "Would add" : "Adding" ). " to SAM location = $location\n" if $verbosity > 8;
    if(not $dryrun) {

        my $numtries = 0;
        my $delay = $sw->delay;
        while(1) {
            ++$numtries;

            my $t1 = [gettimeofday()];
            my $res = $sw->ua->request(
                POST $sw->write_server.'/sam/mu2e/api/files/name/'.$fn.'/locations',
                Content => {'add' => $location }
                );

            $totalLocationUpdateTime += tv_interval($t1);

            if ($res->is_success) {
                print "Added location $pathname to SAM. Server response:\n", Dumper($res), "\n" if $verbosity > 8;
                ++$numAddedLocation;
                return;
            }
            else {
                print STDERR "Error adding location $pathname for for file $fn: ",$res->status_line," on ".localtime()."\n" if $verbosity > 0;
                print STDERR "Dump of the server response:\n", Dumper($res), "\n" if $verbosity > 8;

                if($numtries >= $sw->maxtries) {
                    die "Error: $numtries tries failed. Stopping on ".localtime()." due to: ",
                    $res->status_line, ".\n", $res->content,"\n";
                }
                else {
                    print STDERR "Will retry in $delay seconds\n" if $verbosity > 0;
                    sleep $delay;
                    $delay += int(rand($delay));
                }
            }

        } # retry loop
    } # not(dryrun)
}

#================================================================
sub processFile($$) {
    my ($sw, $pathname) = @_;

    ++$numTotalFiles;

    my $samsha = getSamSha($sw, $pathname);
    if(defined $samsha) {

        if($redo or isNotVerified($sw, $pathname)) {

            print "...... ".localtime()." starting $pathname ......\n" if $verbosity > 2;

            my $passed = 0;
            my $tapeinfo;

            if(tapeBacked($pathname)) {
                $tapeinfo = getEnstoreInfo($pathname);
                if(not defined $tapeinfo) {
                    ++$numNoTape;
                    print "NO_TAPE_LABEL: $pathname\n";
                }
                else {
                    print "Got enstore info: tape = ",$tapeinfo->label,
                    ", cookie = ",$tapeinfo->location_cookie,"\n"
                        if $verbosity > 8;
                }
            }

            if(!tapeBacked($pathname) or defined $tapeinfo) {
                if(hexdigest($pathname) eq $samsha) {
                    $passed = 1;
                    print "OK: $numTotalFiles $pathname\n" if $verbosity > 1;
                    ++$numGood;
                }
                else {
                    print "BADHASH: $numTotalFiles $pathname\n";
                    ++$numBad;
                }
            }

            if($passed) {
                maybeAddLocationToSam($sw, $pathname, $tapeinfo);
            }
        }
        else {
            ++$numSkipped;
            print "SKIPPED: $numTotalFiles $pathname\n" if $verbosity > 3;
        }
    }
    else {
        ++$numNoSam;
        print "NOT_IN_SAM: $numTotalFiles ",basename($pathname),"\n";
    }
}

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage:
        $self [options]

Reads names of files from STDIN, verifies their sha256 checksums
against SAM metadata, and prints results.  For files in the
tape-backed location the script makes sure that a file is on tape (has
an enstore tape volume label) before proceeding with other checks.
Locations of successfully verified files are optionally added to the
SAM database.  If there is a SAM location record that matches an input
file, the processing of the file is skipped by default, as is should
have been verified already.

Options:

    --[no]add-sam-location  [Do not] add location of a successfully
                            verified file to the SAM database.  By
                            default files in $ENV{MU2E_DSROOT_TAPE}
                            have their locations added to SAM while
                            files in other upload areas do not.

    --redo                  Process all files, without skipping those
                            that have their locations already registered.

EOF
. $sw->optDocString(' 'x4, ' 'x7) .
<<EOF

    --verbosity=<int>       Verbosity level. The default is $verbosity.
                            1 print a line per file that failed verification
                            2 printouts for OK and failed, but not skipped files
                            3 also print a  'starting' message before attempting
                              FS operations that can hang
                            4 add printouts for skipped files
                            9 debug

    --help                  Print this message.

EOF
;
}

# Process command line opts.
GetOptions(\%opt,
           "add-sam-location!",
           "redo",
           "verbosity=i",
           "help",
           @{$sw->optSpec},
           )
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

$sw->authConfig();

while(my $line = <STDIN>) {
    chomp($line);
    my $pathname = abs_path($line);
    if($pathname // 0) {
        processFile($sw, $pathname);
    }
    else {
        die "Error: can not determine absolute pathname for input line \"$line\"\n";
    }
}

printf "Computed SHA-256 on %.3f GB in %.2f s\n", $totalReadBytes/1024/1024/1024,  $totalSHATime;
printf "SAMWeb times: query metadata = %.2f s,  query location = %.2f s, update location = %.2f s\n",
    $totalMetadataQueryTime, $totalLocationQueryTime, $totalLocationUpdateTime;

print "Summary1: out of $numTotalFiles input files $numNoSam were not registered in SAM, and $numSkipped had been verified earlier.\n";
print "Summary2: successfully verified $numGood files, added locations for $numAddedLocation files.\n";
print "Summary3: found $numBad corrupted files and $numNoTape files without tape labels.\n";

exit 0;

#================================================================
