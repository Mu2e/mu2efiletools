#!/usr/bin/perl -w
#
# Moves given files to their standard location.
#
# A.Gaponenko, 2015, 2016
#

use strict;
use Fcntl;
use File::Basename;
use File::Path qw(make_path);
use File::stat;
use Getopt::Long;
use Digest;
use Time::HiRes qw(gettimeofday tv_interval);
use Compress::Zlib;
use Cwd 'abs_path';

use Mu2eFilename;

use constant TAPE => 'tape';
use constant DISK => 'disk';
use constant SCRATCH => 'scratch';

my $dstarea; # tape, disk, or scratch
my $forcecopy = 0;
my $verbosity=1;
my $dryrun=0;
my %opt = ( copy=>\$forcecopy, verbosity=>\$verbosity, 'dry-run'=>\$dryrun, help=>0 );

# stat counters for the processing
my $numCopied = 0;
my $numMoved = 0;

my $totalCopiedBytes = 0;
my $totalCopyTime = 0;

#================================================================
sub needToCopy($) {
    my ($infile) = @_;
    return 1 if $forcecopy;
    return 1 if $dstarea eq TAPE();

    my $absin = abs_path($infile);
    return 0 if $dstarea eq DISK() and $absin =~ m|^/pnfs/mu2e/persistent|;
    return 0 if $dstarea eq SCRATCH() and $absin =~ m|^/pnfs/mu2e/scratch|;

    return 1;
}

#================================================================
sub dCacheChecksum {
    my $fn = shift;
    my $ckn = dirname($fn) . '/.(get)('.basename($fn).')(checksum)';
    open(my $fh, '<', $ckn) or die "Error opening pnfs checksum file $ckn : $!\n";
    my $res = <$fh>;
    chomp $res;
    return $res;
}

#================================================================
sub checked_copy($$) {
    my ($infile, $outfile) = @_;

    sysopen(my $in, $infile, O_RDONLY)
        or die "Can not open input \"$infile\": $! on ".localtime()."\n";

    sysopen(my $out, $outfile, O_WRONLY | O_EXCL | O_CREAT)
        or die "Can not create output \"$outfile\": $! on ".localtime()."\n";

    my $blocksize = 4*1024*1024;
    my ($rst, $crc);
    while($rst = sysread($in, my $buf, $blocksize)) {
        $crc = adler32($buf, $crc);
        syswrite($out, $buf)
            or die "Error writing to \"$outfile\": $! on ".localtime()."\n";

    }

    die "Error reading \"$infile\": $! on ".localtime()."\n"
        unless defined $rst;

    close $out or die "Error closing output \"$outfile\": $!  on ".localtime()."\n";
    close $in  or die "Error closing input \"$infile\": $!  on ".localtime()."\n";

    my $checksum = sprintf "ADLER32:%08x", $crc;

    return $checksum;
}

#================================================================
sub processFile($) {
    my ($infile) = @_;
    my $fn = Mu2eFilename->parse(basename($infile));

    my $stdpath;
    $stdpath = $fn->abspathname_tape if($dstarea eq TAPE());
    $stdpath = $fn->abspathname_disk if($dstarea eq DISK());
    $stdpath = $fn->abspathname_scratch if($dstarea eq SCRATCH());
    die "Internal error: unknown dstarea\n" unless defined $stdpath;

    if(-e $stdpath) {
        die "Request to upload $infile, but $stdpath already exists.\n";
    }
    else {

        my $dirpath = dirname($stdpath);
        if(!$dryrun) {
            make_path($dirpath);
            -d $dirpath or die "Error creating dir path $dirpath: $! on ".localtime()."\n";
        }
        my $now_string = localtime();

        my $copy = needToCopy($infile);
        if($copy)  {
            my $st = stat($infile) or die "Error stating $infile: $! on ".localtime()."\n";

            print +($numCopied+$numMoved) , ($dryrun ? "  Would start" : "  Starting"),
            " to transfer ", $st->size, " bytes in $infile to $stdpath on $now_string\n"
                if $verbosity > 0;

            if(!$dryrun) {

                # Use high precision time to measure the data transfer rate.
                my $t1 = [gettimeofday()];

                my $readcheck = checked_copy($infile, $stdpath);

                my $elapsed = tv_interval($t1);

                if(($verbosity > 0) && ($elapsed > 0.1)) {
                    my $datarate = $st->size/1024./1024./$elapsed;
                    print "\t$datarate MiB/s\n";
                }

                $totalCopiedBytes += $st->size;
                $totalCopyTime += $elapsed;

                if(!$dryrun) {
                    my $dstcheck = dCacheChecksum($stdpath);
                    die "Detected data corruption on write: dst checksum = $dstcheck != read checksum $readcheck\n"
                        if($dstcheck ne $readcheck);

                    if($infile =~ m|/pnfs|) {
                        my $srccheck = dCacheChecksum($infile);
                        die "Detected data corruption on read: read checksum = $readcheck != source checksum $srccheck\n"
                            if($srccheck ne $readcheck);
                    }
                }

                if(!$dryrun and !$forcecopy) {
                    unlink $infile
                        or die "Error deleting $infile: $!\n";
                }
            }

            ++$numCopied;
        }
        else {
            print +($numCopied+$numMoved), ($dryrun ? " Would move" : " Moving"), " $infile to $stdpath on $now_string\n"
                if $verbosity > 0;

            if(!$dryrun) {
                rename($infile, $stdpath) or die "Error in rename($infile, $stdpath): $! on ".localtime()."\n";
            }
            ++$numMoved;
        }
    }
}
#================================================================
sub pretty_print_bytes($) {
    my ($size) = @_;
    foreach ('B','KiB','MiB','GiB','TiB') {
        return sprintf("%.2f",$size)." $_" if $size < 1024;
        $size /= 1024;
    }
    return sprintf("%.2f",$size)."PiB";
}

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage:
        $self {--tape|--disk|--scratch} [options]

Will read file names on stdin and try to move each file to its
standard location.

One of the --tape, --disk, or --scratch choices
must be made.  A report on the number of skipped and copied files is
printed at the end.

The supported options are

    --copy                Always copy the files and leave originals in place.
                          By default the script will move files to the destination
                          by either renaming (if possible), or copying and deleting
                          the original.  The --copy option forces to alway
                          copy the files and leave the originals in place.

    --verbosity=<int>     Verbosity level.  The default is 1.

    --dry-run             Do not copy the files, just count and report.

    --help                Print this message.

EOF
;
}

#================================================================
# Process command line opts.
GetOptions(\%opt,
           "tape",
           "disk",
           "scratch",
           "copy",
           "verbosity=i",
           "dry-run",
           "help",
           )
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

die "ERROR: Got non-option command line parameters.  Try the --help option.\n"
    unless $#ARGV ==  -1;


if(defined $opt{'tape'}) {
    die "Error: conflicting options --tape and --$dstarea\n" if defined $dstarea;
    $dstarea = TAPE();
}
if(defined $opt{'disk'}) {
    die "Error: conflicting options --disk and --$dstarea\n" if defined $dstarea;
    $dstarea = DISK();
}
if(defined $opt{'scratch'}) {
    die "Error: conflicting options --scratch and --$dstarea\n" if defined $dstarea;
    $dstarea = SCRATCH();
}
die "Error: one of --tape, --disk, or --scratch must be requested\n" unless defined $dstarea;

my $tScriptStart = [gettimeofday()];
while(my $line = <STDIN>) {
    chomp($line);
    processFile($line);
}
my $totalElapsed = tv_interval($tScriptStart);

print "Summary: copied $numCopied and moved $numMoved files in $totalElapsed seconds.\n";
if($totalCopyTime > 0.1) {
    my $sz = pretty_print_bytes($totalCopiedBytes);
    my $throughput = sprintf "%.2f MiB/s", $totalCopiedBytes/1024./1024./$totalCopyTime;
    print "The average throughput was $sz in $totalCopyTime s = $throughput\n";
}

exit 0;

#================================================================
